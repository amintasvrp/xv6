<!-- Task 05 - Implementar interrupção de relógio

Passos seguidos:

Primeiro, foi necessário encontrar no código onde as interrupções estavam sendo contabilizadas, já que, a task pedia explicitamente para matar um processo a cada “X” interrupções. Para isso, primeiro analisamos o código do xv6 e encontramos uma função sys_uptime no arquivo sysproc.c cuja documentação da mesma dizia: “Retorna quantas interrupções já aconteceram até o momento”.
Analisando a função sys_uptime, nós vimos que ela manipulava e retornava uma variável ticks, que ficou claro que, essa variável seria responsável por armazenar a quantidade de interrupções.
Após tomar conhecimento de onde as interrupções estavam sendo armazenadas, bastou pesquisarmos no código onde elas estavam sendo contabilizadas (vulgo ticks++), e chegamos na função trap, do arquivo trap.c, que dentro de um switch, ela contabilizava esses ticks.
Após achar a área do código que seria chamada toda vez que uma interrupção estava sendo gerada, nós colocamos um if com uma chamada para nossa função interruptProcess. O motivo dessa chamada ser dentro de um if é para que essa função seja chamada apenas quando houver a necessidade, ou explicitamente falando, a cada “X” ticks.
Por fim, quando a função interruptProcess, cuja implementação está no arquivo proc.c é chamada, sua principal ação é, adquirir a tabela de processos (para que nenhuma outra thread atrapalhe a execução do código) e com essa tabela em mãos, varrê-la de modo a procurar o último processo “matável”. O que seria um processo “matável”? Simples: No xv6, existem dois processos básicos rodando, o init e o sh, esses processos não podem ser mortos, pois caso sejam, o sistema será afetado. Uma vez que o interruptProcess varre a tabela de processos e acha alguém diferente do init e sh (a.k.a processo matável), ele grava seu pid (process id) em uma variável temporária e devolve a tabela de processos para uso de outras threads. É importante dizer que, caso exista mais de um processo “matável”, o último será escolhido para morrer. Após ter o pid do processo a ser morto em mãos, é chamada a função kill (cuja implementação também está no arquivo proc.c) passando como parâmetro esse pid, e ela se encarregará de matar o processo. Ao final de tudo a função interruptProcess retorna o pid do processo que foi morto, caso nenhum seja morto, retornará 0.
 
	p.s: No xv6, processos que estão com o estado UNUSED possuem PID 0, e os processos básicos do sistema, init e sh, possuem PID 1 e 2, por isso, ao varrer a tabela de processos em busca de um processo matável, apenas processos com PID > 2 são escolhidos. -->
